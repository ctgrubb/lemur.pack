---
title: "Meeting Doc"
author: "Christopher Grubb"
date: "9/13/2021"
output: 
  bookdown::html_document2:
    toc: true
    toc_float: true
    toc_depth: 2
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE)

options(scipen = 999)

library(lemur.pack)
library(extraDistr)
library(dplyr)
library(ggplot2)
library(gridExtra)
```

# Introduction

## Data

We will use built-in data from our package.

```{r dataload}
data("ex1pop")
data("ex1samp")

pop <- ex1pop %>%
  select(HousePrice, HousePriceCat)

samp <- ex1samp %>%
  select(Income, IncomeCat, HousePriceCat)
```

We observe the housing prices from the full population, but we only get raw incomes from a simple random sample. The SRS also contains binned housing price data.

```{r datadesc, echo = FALSE, out.width = "100%", fig.height = 7, fig.cap = ""}
countDf <- pop %>% 
  group_by(HousePriceCat) %>%
  summarize(Count = n(), .groups = "drop") %>%
  mutate(Location = c(40000, 110000, 180000, 290000, 420000))

g1 <- ggplot(data = pop, mapping = aes(x = HousePrice)) + 
  geom_histogram(breaks = seq(0, 560000, by = 20000), fill = "darkgreen", alpha = 0.5) + 
  labs(x = "Housing Price", y = "Count") + 
  geom_vline(xintercept = c(80000, 140000, 220000, 360000), linetype = "dashed") + 
  geom_label(data = countDf, mapping = aes(x = Location, label = Count), y = 100)

countDf <- samp %>%
  group_by(IncomeCat, HousePriceCat, .drop = FALSE) %>%
  summarize(Count = n(), .groups = "drop")

g2 <- ggplot(data = countDf, mapping = aes(x = HousePriceCat, y = IncomeCat, fill = Count)) + 
  geom_tile() + 
  geom_label(data = countDf[countDf$Count > 0, ], mapping = aes(label = Count), fill = "white") + 
  scale_fill_gradient(low = "white", high = "black") + 
  labs(x = "Housing Price", y = "Income")

grid.arrange(g1, g2, nrow = 2, ncol = 1)
```

## Goal

Our goal is to create synthetic populations using the observed raw data, in a way that respects the observed sample. Since we know the housing prices for the entire population, we will use those. 

# Methods

## Basic (Independent Normal, Binomial)

First, we will use a Normal distribution assumption for the incomes, and we will assume they are *independent* of housing prices.

\begin{align*}
X_c &= (I_c, H_c) \\
X &= (I, H) \\
H &\sim F(h) \\
I &\sim Norm(\mu, \sigma^2)
\end{align*}

The following is a relatively straight-froward MCMC algorithm which will sample from the posterior representing this scenario.

```{r}
sample <- samp
population <- pop
iterations <- 30
```


```{r indNormal}
indNormalMCMC <- function(sample, population, iterations = 1000) {
  
  toLLik <- function(df) {
    dfCat <- df %>%
      mutate(
        IncomeCat = case_when(
          Income < 40000 ~ "<40000",
          Income < 65000 ~ "40000-64999",
          Income < 110000 ~ "65000-109999",
          TRUE ~ ">=110000"
        ),
        HousePriceCat = case_when(
          HousePrice < 80000 ~ "<80000",
          HousePrice < 140000 ~ "80000-139999",
          HousePrice < 220000 ~ "140000-219999",
          HousePrice < 360000 ~ "220000-359999",
          TRUE ~ ">=360000"
        )
      ) %>%
      mutate(
        IncomeCat = factor(IncomeCat, levels = c("<40000", "40000-64999", "65000-109999", ">=110000")),
        HousePriceCat = factor(HousePriceCat, levels = c("<80000", "80000-139999", "140000-219999", "220000-359999", ">=360000"))
      )
    
    dfTable <- table(dfCat$IncomeCat, dfCat$HousePriceCat, exclude = FALSE)
    out <- 0
    for(i in 1:nCatsH) {
      out <- out + dmvhyper(tab[, i], dfTable[, i], tal[i], log = TRUE)
    }
    return(out)
  }
  
  l1 <- levels(sample$IncomeCat)
  l2 <- levels(sample$HousePriceCat)
  
  tab <- table(sample[, -1], exclude = FALSE)
  mar <- as.numeric(table(population$HousePriceCat, exclude = FALSE))
  tal <- as.numeric(table(sample$HousePriceCat, exclude = FALSE))

  nCatsI <- length(l1)
  nCatsH <- length(l2)
  
  N <- nrow(population)
  mu <- mean(sample$Income)
  sig <- sd(sample$Income)
  step <- 30000
  
  current <- data.frame(
    Income = rnorm(N, mu, sig),
    HousePrice = sample(pop$HousePrice)
  )
  
  while(!is.finite(toLLik(current))) {
    current$Income <- rnorm(N, mu, sig)
  }
  
  out <- list()
  
  for(i in 1:iterations) {
    propDf <- current
    for(k in 1:N) {
      proposal <- rtnorm(1, current[k, 1], step, 0, Inf)
      propDf[k, 1] <- proposal
    
      # compare
      alpha <- toLLik(propDf) + dnorm(current[k, 1], mu, sig, log = TRUE) - 
        toLLik(current) - dnorm(proposal, mu, sig, log = TRUE) + 
        dtnorm(current[k, 1], proposal, step, 0, Inf, log = TRUE) - dtnorm(proposal, current[k, 1], step, 0, Inf, log = TRUE)
      if(is.finite(alpha) & log(runif(1)) < alpha) {
        # Acceptance
        current <- propDf
      } else {
        # Rejection
        propDf <- current
      }
    }
    out[[i]] <- current
  }
  return(out)
}
```

```{r}
test <- indNormalMCMC(samp, pop, 20)
```

